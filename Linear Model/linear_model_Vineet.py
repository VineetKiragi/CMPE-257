# -*- coding: utf-8 -*-
"""Linear_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WShh8f3WvUT4mbESKykDJxk_OEjK3a3u
"""

import numpy as np, pandas as pd
import json
import ast 
from textblob import TextBlob
import nltk
import torch
import pickle
from scipy import spatial
import warnings
warnings.filterwarnings('ignore')
import spacy
from nltk import Tree
#en_nlp = spacy.load('en')
from nltk.stem.lancaster import LancasterStemmer
st = LancasterStemmer()
from sklearn.feature_extraction.text import TfidfVectorizer, TfidfTransformer

train = pd.read_csv("data.csv")

train.shape

"""Loading Embedding dictionary"""

with open("/content/dict_embeddings1.pickle", "rb") as f:
    d1 = pickle.load(f)

with open("/content/dict_embeddings2.pickle", "rb") as f:
    d2 = pickle.load(f)

dict_emb = dict(d1)
dict_emb.update(d2)

len(dict_emb)

del d1, d2

"""Data Processing"""

def get_target(x):
    idx = -1
    for i in range(len(x["sentences"])):
        if x["answer"] in x["sentences"][i]: idx = i
    return idx

train.head(3)

train.dropna(inplace=True)

train.shape

def process_data(train):
    
    print("step 1")
    train['sentences'] = train['text'].apply(lambda x: [item.raw for item in TextBlob(x).sentences])
    
    print("step 2")
    train["target"] = train.apply(get_target, axis = 1)
    
    print("step 3")
    train['sent_emb'] = train['sentences'].apply(lambda x: [dict_emb[item][0] if item in\
                                                           dict_emb else np.zeros(4096) for item in x])
    print("step 4")
    train['quest_emb'] = train['question'].apply(lambda x: dict_emb[x] if x in dict_emb else np.zeros(4096) )
        
    return train

train = process_data(train)

train.head()

"""Predicted Cosine & Euclidean Index"""

def cosine_sim(x):
    li = []
    for item in x["sent_emb"]:
        li.append(spatial.distance.cosine(item,x["quest_emb"][0]))
    return li

def pred_idx(distances):
    return np.argmin(distances)

def predictions(train):
    
    train["cosine_sim"] = train.apply(cosine_sim, axis = 1)
    train["diff"] = (train["quest_emb"] - train["sent_emb"])**2
    train["euclidean_dis"] = train["diff"].apply(lambda x: list(np.sum(x, axis = 1)))
    del train["diff"]
    
    print("cosine start")
    
    train["pred_idx_cos"] = train["cosine_sim"].apply(lambda x: pred_idx(x))
    train["pred_idx_euc"] = train["euclidean_dis"].apply(lambda x: pred_idx(x))
    
    return train

predicted = predictions(train)

predicted.head(3)

predicted["cosine_sim"][0]

predicted["euclidean_dis"][0]

"""Accuracy"""

def accuracy(target, predicted):
    
    acc = (target==predicted).sum()/len(target)
    
    return acc

"""Accuracy for euclidean Distance"""

print(accuracy(predicted["target"], predicted["pred_idx_euc"]))

"""Accuracy for Cosine Similarity"""

print(accuracy(predicted["target"], predicted["pred_idx_cos"]))

